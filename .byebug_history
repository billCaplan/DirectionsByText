q
n
s
breakdown[0]
q
breakdown[0].downcase.strip() === "driving || "drive"
breakdown[0].downcase.strip() === "drive" || "driving"
breakdown[0].downcase.strip() === "driving || "drive" 
breakdown[0].downcase.strip() === "driving || "drive"
breakdown[0].downcase.strip() === "drive" || "driving"
breakdown[0].downcase.strip() === "drive" 
breakdown[0].downcase.strip() === "drive"
s
breakdown[0].downcase.strip()
q
breakdown[0].downcase
breakdown[0]
breakdown
q
mode
q
finalString
q
finalString
q
finalString.each {|chunk| p "This chunk is #{chunk} \n\n\n\n"}
q
finalString.each {|chunk| p "This chunk is #{chunk} \n\n\n\n"}
finalString.each {|chunk| p "This chunk is #{chunk} \n"}
finalString
q
finalString[iterator]
finalString[iterator].length
n
finalString[iterator].length
n
finalString[iterator]
finalString[iterator] += "#{step['html_instructions']} \n"
finalString[iterator]
n
s
iterator = 0
iterator
iterator += 1
finalString[iterator].length >= 1500
finalString[iterator].length
q
n
finalString
n
finalString[iterator]
response
finalString
q
finalString[1590]
finalString.length
finalString.scan(/.{1,600}/)
finalString
chunks.each {|chunk| p "This chunk is #{chunk} \n"}
chunks
q
 finalString.scan(/.{1600}/)
finalString.length()
finalString
chunks
chunks.each {|chunk| p "This chunk is #{chunk} \n"}
q
chunks.each {|chunk| p "This chunk is #{chunk} \n"}
chunks
q
chunks
q
finalString.scan{/.{1600}/}
finalString
chunks
q
Rails.application.secrets.twilio_token
q
n
s
q
finalString
n
q
response.parsed_response['routes'][0]['legs'][0]['steps'][1]['html_instructions']
response.parsed_response['routes'][0]['legs'][0]['steps'][0]['html_instructions']
response.parsed_response['routes'][0]['legs'][0]['steps'][0]['distance']
response.parsed_response['routes'][0]['legs'][0]['steps'][0].distance
response.parsed_response['routes'][0]['legs'][0]['steps'][0]
response.parsed_response['routes'][0]['legs'][0]['steps'].each {|step| p step["distance']}
response.parsed_response['routes'][0]['legs'][0]['steps'].each {|step| p step.["distance']}
response.parsed_response['routes'][0]['legs'][0]['steps'].each {|step| p step.distance}
response.parsed_response['routes'][0]['legs'][0]['steps'].each {|step| p step.distance
response.parsed_response['routes'][0]['legs'][0]['steps']
response.parsed_response['routes'][0]['legs'].steps
response.parsed_response['routes'][0]['legs']['steps']
response.parsed_response['routes'][0]['legs'][0]
response.parsed_response['routes'][0]['legs'].each {|leg| p leg['html_instructions']}
response.parsed_response['routes'][0]['legs'].each {|leg| p leg}
response.parsed_response['routes'][0]['legs']
response.parsed_response['routes'][0]['bounds']
response.parsed_response['routes'][0].each {|thing| p thing}
response.parsed_response['routes'][0] 
response.parsed_response['routes'][2] 
response.parsed_response['routes'][1] 
response.parsed_response['routes'][0] 
response.parsed_response['routes'].each {|thing| p thing + "\n"} 
response.parsed_response['routes'].each {|thing| p thing p "    "} 
response.parsed_response['routes'].each {|thing| p thing p \n} 
response.parsed_response['routes'].each {|thing| p thing} 
response.parsed_response['routes'].each do |thing| {p thing} end 
response.parsed_response['routes'].each do |thing| {p thing}
response.parsed_response['routes']
response.parsed_response['routes'].legs
response.parsed_response['routes'].keys
response.parsed_response['routes'].['legs'].['steps']
response.parsed_response['routes'].['legs']['steps']
response.parsed_response['routes']['legs']['steps']
response.parsed_response['routes']
response.parsed_response[routes]
response.parsed_response.routes
response.parsed_response."routes"
response.parsed_response.keys.routes
response.parsed_response.keys
response.parsed_response.geocoded_waypoints
response.parsed_response.routes
response.parsed_response
response
response.routes
response
q
n
createUseableDirections(finalJSON)
n
response.parsed_response
response
n
url
